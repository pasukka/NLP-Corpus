

Сложное поведение без нейросетей и обучения. Философский базис / Habr


              14  May  2020 at 22:54  Сложное поведение без нейросетей и обучения. Философский базис Abnormal programming *Artificial Intelligence DIY       
Задача управления движением интересна сама по себе. Как заставить механическую куклу решать задачи в трёхмерном пространстве? Пусть даже простые. Подойти к столу, взять предмет, перенести его, положить в корзину. Не упасть по дороге. Никуда не врезаться.
Роботы Boston Dynamics, весьма вдохновенны. Вещи которые они делают поразительны. Как что-то похожее получить в домашних условиях? Как вообще подойти к этой задаче и насколько она посильна?
Иерархическое управление
Для успешного управления существом, подобным живому потребуется одновременно решать огромное количество задач совершенно разной природы. Тут вам и системы контроля движения, обработка изображений, планирование, системы избегания опасностей. Размерность задачи велика и обозреть её целиком будет весьма непросто.
Однако мы знаем, что нужно делать. Декомпозиция задачи открывает путь к построению сложной системы из многих простых. Если каждый уровень обозрим, и предсказуем, то сложное становится возможным. Иерархическая система управления как слоёный пирог. Системы подчинены друг другу, каждая отвечает за свой узкий участок. 
В книге "Кибернетика или управление и связь в животном и машине" Норберт Винер пишет: "Чтобы взять карандаш, нужно на каждом шаге минимизировать степень того, в какой карандаш ещё не взят". Если я не могу взять карандаш сам, то для того, чтобы минимизировать степень его невзятости, я просто поручу это тому, кто на это способен. Бесконечное делегирование — это тот способ с помощью которого можно делать очень сложные вещи. Если я правильно сформулировал задачу своей подсистеме, то она, решая вопрос минимизации по сформулированной мной подзадаче, автоматически будет минимизировать степень того, в какой карандаш еще не взят, даже не подозревая об истинной цели всего мероприятия. 
В иерархической системе управления управление сводится к разбиению задачи на простые части. Для каждой возможной подзадачи есть специализированная подсистема, которая умеет эту подзадачу выполнять. Система высшего уровня не пытается контролировать движение каждого двигателя или мышцы. Вместо этого она формулирует для подчиненных структур ту ситуацию, которую ей желательно получить на том языке, который понятен этой подсистеме. Нижележащие системы получив это задание распаковывают его в более низкоуровневой трактовке и так до тех пор, пока желание съесть яблоко не превращается в потенциал действия на актуаторных нейронах. 
Пусть у нас есть некий механизм, который необходимо научить двигаться и решать задачи по взаимодействию с объектами. Мы не требуем пока, чтобы он проявлял чудеса интеллекта. Только простые двигательные задачи. Допустим, наш автоматон получил задание положить груз, лежащий в точке А в контейнер находящийся в точке Б. Как такую задачу можно решить в терминах иерархической системы?
Если проанализировать задачу, она состоит из нескольких явно выраженных подзадач. Во первых мы должны добраться до точки А, по пути не умерев. Найти груз. Взять груз, ничего не уронив и не умерев. Переместиться в точку Б, неся груз и по пути не умерев. Найти контейнер. Положить груз в контейнер, ничего на себя не опрокинув и не умерев. Каждая из отдельных задач раскладывается на несколько подзадач. Например, чтобы взять груз, нужно переместить манипулятор (ни с чем не столкнувшись), подвести манипулятор, не деформировал груз, и крепко захватить груз. 
Простые движения, вроде "сжать схват", или "разжать схват", или "переместить манипулятор" будут повторяться в разных двигательных подпрограммах. Из них строится задача более высокого уровня и так далее. Решить всю последовательность алгоритма одной функцией можно, но мы не сможем переиспользовать такое решение при изменении задачи. Принцип декомпозиция предлагает разбить эту функцию и переиспользовать результаты.
Как это работает?
Введём некоторый стратегический контроллер. Перед ним поставлена задача перенести объект из точки А в точку Б. На каждом шаге алгоритма он должен оценить текущее состояние.

Где находится груз?

Может быть груз уже в точке Б? Окей. Задача выполнена.

Груз у меня? Тогда я должен положить груз в контейнер в точке Б.

Груз не у меня? Я должен взять груз. Где он? Может быть в точке А, или я его уронил. Не имеет значения, я должен взять груз.
Теперь я функция, которой велели взять груз. Я оцениваю состояние.

Я далеко от груза?

Да? Я попрошу контроллер позиционирования тела приблизить меня.

Я достаточно близко? Я попрошу систему управления манипуляторами произвести захват объекта.
А вот я система управления позиционированием и мне велели двигаться к точке А. Я оцениваю своё состояние.

Я могу продолжать движение? Как нет? Я лежу на полу? Думаю, мне стоит активировать программу восстановления вертикального положения.

Я могу продолжать движение? Да.

Я должен двигаться быстро? Если да, активирую контроллер бега и передаю ему направление.

Если нет, передаю направление контроллеру шага.

Впереди препятствие? Чуть-чуть скорректируем вектор направления, чтобы обойти препятствие стороной.
А вот я контроллер шага. Я смотрю своё состояние.

Левая нога занесена, но довольно долго висит в воздухе, её стоит смещать вниз.

Скорость смещения корпуса отличается от оптимальной. Перерасчитаем желаемое положение выходного сустава правой ноги.

Левая нога может столкнуться с препятствием, сместим её чуть вправо.

Есть потеря равновесия? Учтём это при постановке ноги.
А вот я контроллер отдельной конечности. У меня задача простая. Обеспечить требуемое относительное положение стопы и бедра.

Я оцениваю состояние, смотрю текущие положения суставов и их скорости и рассчитываю, как надо их поменять, чтобы получить требуемое, а команды эти отправляю контроллерам отдельных узлов.
И вот я система управления суставом. Всю свою сознательную жизнь я решал одну, строго одну и только одну задачу: Следил за тем, чтобы положение сустава не сбивалось относительно положения уставки. Что я делаю? Оцениваю состояние. Если положение не совпадает или скорость отлична от требуемой, я чуть-чуть поднапрягу мышцы. Я молодец!
Верите ли вы, что такая система может решить задачу?
В приведённом выше обзоре не хватает нескольких деталей. Во первых в ней неявно присутствует обработка сенсорной информации. Действительно, кто сказал, контроллеру шага, что нога находится в том состоянии, в котором она находится? Вы, кстати, обратили внимания, что в системе не задействовано никакой памяти? Есть два канала получения информации: восходящий и оценочный. Восходящий канал — это информация, которую предоставляет подсистема. Подсистема имеет некоторую оценку своего состояния и трактует его для вышестоящего уровня. Это локальная система. Канал оценки — это информация полученная из прочих источников, например в результате визуальной оценки состояния собственных конечностей. Оценочные каналы идут от внутренней модели, строящейся по результатом работы всех сенсоров системы. Это глобальная модель. Локальная модель работает быстро, но она ограничена своим уровнем понимания. Глобальная модель работает медленно, но даёт оценку на основе большего количества информации.
Системы управления можно дробить по-разному. Низкие уровни достаточно хорошо оформлены и понятны, поскольку завязаны на аппаратную часть. С высшими сложнее. Иерархия может расти вверх достаточно долго. Пусть, например, задача по переносу груза — часть задачи по переносу содержимого всего склада. А что, если складов два. Это не то, что эффективно можно решить простым масштабированием.
Пара слов про исток
Так или иначе, сверху всегда есть то, что принимает решение и вызывает нужную программу. Некий исток всего поведения. Контроллер стратегического планирования решает строго одну задачу. Максимизирует некоторый параметр, который может иметь, а может не иметь физического смысла. В нашем примере с карандашом смыслом всего было взятие карандаша, а оценка всего сущего выражалась в томительной мере неудовольствия тем простым фактом, что карандаш до сих пор не взят. Но, программа взятия карандаша может быть инициирована другой системой, что выражает лютое негодование тем фактом, что картина до сих пор не нарисована. Что за функция будет поставлена во главу угла — это вопрос применения системы. Потенциально система неограниченно растёт вверх, на каждом уровне решая всё более и более абстрактные задачи, но такое построение ограничено соображениями обозримости. Рано или поздно встаёт вопрос о некоем более разумном планировании, то есть о специальной системе, которая целенаправленно занимается планированием и генерацией цепочек подзадач. Эта система должна быть близка к истоку.
Исток поведения неизменен. Есть два способа заставить систему работать дольше одного цикла — первый связан с изменением среды. Если счастье робота определяется фактом наличия груза в контейнере, то до тех пор, пока груз на месте, робот не будет делать ничего. Но если груз выкинуть из контейнера, он пойдёт его возвращать. Другой способ в правильном формировании истока. Если функция хорошечности всё время падает, роботу придётся постоянно совершать действия по её повышению.
В книге "Автономный искусственный интеллект (Адаптивные и интеллектуальные системы)" за авторством профессора Жданова А.А., максимизируемый (минимизируемый) системой параметр называется оценкой хорошечности, а исток поведения хорошометром. Книга посвящена обучению и автономному поведению. Материал, изложенный в ней можно использовать, чтобы внести мотив обучения в автоматона. Хотя может показаться, что концепция обучаемых машин противна тем механистическим констрактам, о которых идёт речь в этой статье, принципы, на которых строятся эти системы отлично стыкуются. Можно даже сказать, что это та же самая система. Вопросы о том, как и когда использовать обучение, и когда этого делать не нужно, я постарался прояснить в прошлой своей статье. В ней показано, что кибернетическая система должна разворачивать функции обучения поверх некоторой наперёд заданной структуры, а структуру эту нужно разработать настолько тщательно, насколько это вообще возможно. Чем больше высокоуровневых функций будет у адаптивных механизмов к моменту начала обучения, тем проще ему будет учиться, и тем меньшая размерность будет у задачи обработки информации.
    Tags: роботповедениефилософия Hubs: Abnormal programmingArtificial IntelligenceDIY          


