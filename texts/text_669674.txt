

Рейтинг русскоязычных энкодеров предложений / Habr


              5  June   at 22:18  Рейтинг русскоязычных энкодеров предложений Python *Semantics *Machine learning *Natural Language Processing *      Энкодер предложений (sentence encoder) – это модель, которая сопоставляет коротким текстам векторы в многомерном пространстве, причём так, что у текстов, похожих по смыслу, и векторы тоже похожи. Обычно для этой цели используются нейросети, а полученные векторы называются эмбеддингами. Они полезны для кучи задач, например, few-shot классификации текстов, семантического поиска, или оценки качества перефразирования. Но некоторые из таких полезных моделей занимают очень много памяти или работают медленно, особенно на обычных CPU. Можно ли выбрать наилучший энкодер предложений с учётом качества, быстродействия, и памяти? Я сравнил 25 энкодеров на 8 задачах, и составил их рейтинг. Самой качественной моделью оказался mUSE, самой быстрой из предобученных – FastText, а по балансу скорости и качества победил rubert-tiny2. Код бенчмарка выложен в репозитории encodechka, а подробности – под катом. Родственные проектыПервой известной попыткой системно сравнить английские эмбеддинги предложений был SentEval, сочетающий чисто лингвистические задачи со вполне прикладными. Для русского языка тоже было создано немало разного рода бенчмарков NLU моделей:RussianSuperGLUE: бенчмарк "сложных" NLP задач; фокус на дообучаемых моделях.MOROCCO: RussianSuperGLUE + оценка производительности, довольно трудновоспроизводимый бенчмарк. RuSentEval: бенчмарк BERT-подобных энкодеров предложений на лингвистических задачах. Статья от Вышки Popov et al, 2019: первая научная статья по русским энкодерам предложений; увы, содержит маловато моделей и задач.SentEvalRu и deepPavlovEval: два хороших, но давно не обновлявшихся прикладных бенчмарка.Мой бенчмарк вырос из поста Маленький и быстрый BERT для русского языка, где я, обучив модель rubert-tiny, сравнивал её с другими русскоязычными бертами. С тех пор появилось много новых русскоязычных моделей, включая rubert-tiny2, поэтому и бенчмарк пришло время обновить.  МоделиВ основу бенчмарка легли BERT-подобные модели: sbert_large_nlu_ru, sbert_large_mt_nlu_ru, и ruRoberta-large от Сбера; rubert-base-cased-sentence, rubert-base-cased-conversational, distilrubert-tiny-cased-conversational, и distilrubert-base-cased-conversational от DeepPavlov; мои   rubert-tiny и rubert-tiny2; мультиязычные LaBSE (плюс урезанная версия LaBSE-en-ru) и старый добрый bert-base-multilingual-cased. Для каждой такой модели я использовал два вида эмбеддингов: или эмбеддинг первого (CLS) токена, или средний эмбеддинг всех токенов. Кроме этого, я добавил в бенчмарк разные T5 модели, т.к. они тоже должны хорошо понимать тексты: мои rut5-small, rut5-base, rut5-base-multitask, и rut5-base-paraphraser, и Сберовские ruT5-base и ruT5-large. Для них я использовал только средний эмбеддинг всех токенов. Помимо BERTов и T5, я включил в бенчмарк большие мультиязычные модели Laser от FAIR и USE-multilingual-large от Google. В качестве быстрого бейзлайна, я добавил FastText, а именно, geowac_tokens_none_fasttextskipgram_300_5_2020  с RusVectores, а также его сжатую версию. Наконец, я добавил парочку "моделей", которые вообще не выучивают никаких параметров, а просто используют HashingVectorizer для превращения текста в вектор признаков. Ни одну из моделей я не дообучал на задачи из бенчмарка. Вместо этого я извлекал из них эмбеддинги текстов "как есть" и обучал простенькие модели, используя эти эмбеддинги как признаки. Таким образом, мой бенчмарк (в отличие, скажем, от RussianSuperGLUE) ранжирует модели не по способности к дообучению, а по качеству уже выученных представлений текстов.Про rubert-tiny2Про rubert-tiny2 я расскажу подробнее, потому что эту модель я ранее нигде не описывал. Это доработанная версия rubert-tiny: я расширил словарь модели c 30К до 80К токенов, увеличил максимальную длину текста с 512 до 2048 токенов, и дообучил модель на комбинации задач masked language modelling, natural language inference, и аппроксимации эмбеддингов LaBSE. Код дообучения есть в блокноте. В результате увеличения словаря я улучшил модель по нескольким показателям. Во-первых, за счёт выделенных эмбеддингов она начала лучше понимать смысл слов: например, у неё появился отдельный эмбеддинг для слова "коронавирус" и возможность запомнить его смысл. Это, в свою очередь, позволило "высвободить" слои self-attention, чтобы модель могла уделять больше внимания смыслу текста в целом. Во-вторых, за счёт увеличения словаря сократилось число среднее токенов на один текст, а значит, модель стала быстрее работать на CPU (где нет возможности обрабатывать токены параллельно). В-третьих, увеличение словаря вкупе с увеличением числа positional embeddings позволило запихивать в модель более длинные тексты, чем раньше. Я надеялся, что все эти улучшения сильно повысят качество модели, и в принципе мои надежды оправдались. Вторая версия rubert-tiny стала занимать больше памяти, чем первая (за счёт увеличенной матрицы эмбеддингов), но чуть быстрее работать (из-за увеличения покрытия словаря), а главное, давать более качественные эмбеддинги текстов. Задачи и оценка качестваВ новой версии бенчмарка я оставил всё те же 10 задач, что и в прежней, но слегка изменил формат некоторых из них:Semantic text similarity (STS) на основе переведённого датасета STS-B;Paraphrase identification (PI) на основе датасета paraphraser.ru;Natural language inference (NLI) на датасете XNLI; Sentiment analysis (SA) на данных SentiRuEval2016. В прошлой версии бенчмарка я собрал кривые тестовые выборки, поэтому этот датасет я переделал;Toxicity identification (TI) на датасете токсичных комментариев из OKMLCup;Inappropriateness identification (II) на датасете Сколтеха;Intent classification (IC) и её кросс-язычная версия ICX на датасете NLU-evaluation-data, который я автоматически перевёл на русский. В IC классификатор обучается на русских данных, а в ICX – на английских, а тестируется в обоих случаях на русских. Распознавание именованных сущностей () на датасетах factRuEval-2016E1) и RuDReC (NE2). Эти две задачи требуют получать эмбеддинги отдельных токенов, а не целых предложений; поэтому модели USE и Laser, не выдающие эмбеддинги токенов "из коробки", в оценке этих задач не участвовали. В задачах STS, PI и NLI оценивается степень связи двух текстов. Хороший энкодер предложений должен отражать эту степень в их косинусной близости, поэтому для STS и PI мы измеряем качество как Спирмановскую корреляцию косинусной близости и человеческих оценок сходства. Для NLI я обучил трёхклассовую (entail/contradict/neutral) логистическую регрессию поверх косинусной близости, и измеряю её точность (accuracy). Для задач бинарной классификации TI и II я измеряю ROC AUC, а в задачах многоклассовой классификации SA, IC и ICX – точность (accuracy). Для всех задач классификации я обучаю логистическую регрессию либо KNN поверх эмбеддингов предложений, и выбираю лучшую модель из двух. Для задач NER я классифицировал токены логистической регрессией поверх их эмбеддингов, и измерял macro F1 по всем классам токенов, кроме О. Поскольку разные модели токенизируют тексты по-разному, я токенизировал все тексты razdel'ом, и вычислял эмбеддинг слова как средний эмбеддинг его токенов. Поскольку все метрики качества лежат между 0 и 1, агрегированное качество по всем задачам можно репортить просто как среднее арифметическое. Я вычисляю два таких средних: по первым 8 задачам (где используются только эмбеддинги предложений), и по всем 10 (включая NER, где участвуют также эмбеддинги токенов).Кроме качества моделей на конечных задачах, я замерял их производительность (среднее число миллисекунд на предложение при запуске на CPU либо GPU) и размер (в мегабайтах, которые модель занимает на диске). РезультатыПервая таблица показывает перформанс моделей в каждой из задач. Единого победителя нет, но MUSE, sbert_large_mt_nlu_ru и rubert-base-cased-sentence взяли по многу призовых мест. Удивительно, но модели T5 очень хорошо показали себя на задачах NER. Таблица 1: качество по задачамmodelSTSPINLISATIIAICICXNE1NE2MUSE-30.810.610.420.770.960.790.770.75sentence-transformers/LaBSE0.770.640.430.760.940.770.750.740.350.41cointegrated/LaBSE-en-ru0.770.640.430.760.940.770.750.740.340.41laser0.750.60.410.730.960.720.720.7cointegrated/rubert-tiny20.750.650.420.730.930.750.690.590.40.4sberbank-ai/sbert_large_mt_nlu_ru0.770.640.40.790.980.80.70.420.30.34DeepPavlov/rubert-base-cased-sentence0.730.660.490.750.890.750.610.360.360.34sberbank-ai/sbert_large_nlu_ru0.650.610.380.780.970.790.680.370.360.4DeepPavlov/distilrubert-base-cased-conversational0.570.520.360.730.980.780.670.420.40.43DeepPavlov/distilrubert-tiny-cased-conversational0.590.520.370.710.980.780.660.360.350.44ft_geowac_full0.690.530.370.720.970.760.660.260.220.34cointegrated/rut5-base-paraphraser0.640.530.360.690.910.690.610.50.450.41cointegrated/rubert-tiny0.650.510.40.680.860.680.580.540.230.34ft_geowac_21mb0.680.520.360.720.960.740.650.150.210.32DeepPavlov/rubert-base-cased-conversational0.540.530.340.720.970.760.620.260.40.43cointegrated/rut5-base-multitask0.620.50.360.660.880.690.570.320.470.41sberbank-ai/ruRoberta-large0.380.580.330.70.980.770.560.240.290.45bert-base-multilingual-cased0.620.510.360.660.850.690.560.230.350.37hashing_1000_char0.70.530.40.70.840.590.630.050.050.14cointegrated/rut5-small0.590.520.340.650.860.670.530.150.440.38hashing_300_char0.690.510.390.670.750.570.610.040.030.08hashing_10000.630.490.390.660.770.550.570.050.020.04sberbank-ai/ruT5-large0.40.340.350.670.940.730.470.160.460.44hashing_3000.610.480.40.640.710.540.50.050.020.02sberbank-ai/ruT5-base0.280.230.350.620.880.660.370.140.450.41cointegrated/rut5-base0.370.210.340.610.830.680.350.130.480.39Вторая таблица показывает среднее качество каждой из моделей, а также их скорость и размер. Самыми качественными энкодерами предложений оказались мультиязычные MUSE, LaBSE и Laser. Кажется, это означает, что параллельные мультиязычные корпусы – это очень  хороший источник семантики для обучения моделей, понимающих смысл текста. За мультиязычными моделями следует rubert-tiny2. Таблица 2: среднее качество и производительностьmodelCPUGPUsizeMean SMean S+WMUSE-366.218.53030.736sentence-transformers/LaBSE105.97.517500.7260.657cointegrated/LaBSE-en-ru1067.54920.7250.656laser118.88.82000.699cointegrated/rubert-tiny24.92.71120.6890.631sberbank-ai/sbert_large_mt_nlu_ru35614.415900.6870.613DeepPavlov/rubert-base-cased-sentence100.67.66780.6560.594sberbank-ai/sbert_large_nlu_ru348.614.215900.6540.599DeepPavlov/distilrubert-base-cased-conversational49.74.55170.6290.587DeepPavlov/distilrubert-tiny-cased-conversational16.82.14090.620.575ft_geowac_full0.619100.6170.55cointegrated/rut5-base-paraphraser118.89.19320.6170.579cointegrated/rubert-tiny6.12.8450.6140.549ft_geowac_21mb1.4210.5970.531DeepPavlov/rubert-base-cased-conversational98.87.66810.5910.557cointegrated/rut5-base-multitask117.89.49320.5750.548sberbank-ai/ruRoberta-large354.914.113200.5680.528bert-base-multilingual-cased124.67.86810.5610.521hashing_1000_char0.510.5570.464cointegrated/rut5-small31.87.12470.540.514hashing_300_char0.510.5280.433hashing_10000.210.5130.416sberbank-ai/ruT5-large339.914.427500.5080.497hashing_3000.210.4910.397sberbank-ai/ruT5-base94.38.18500.4420.44cointegrated/rut5-base119.69.69320.4390.439Модель с наилучшим средним качеством – только одна (mUSE), но это не значит, что всегда надо выбирить именно её; скорость и память тоже важны. Но выбирать стоит из Парето-оптимальных моделей: таких, что ни одна другая модель не превосходит их по всем критериям. Из 25 моделей только 12 Парето-оптимальны:MUSE, rubert-tiny2, FT_geowac, Hashing_1000_char и Hashing_1000 обладают самым лучшим качеством для своей скорости на CPU;MUSE, LaBSE, rubert-tiny2, и distilbert-tiny обладают наилучшим качеством для своей скорости на GPU;MUSE, LaBSE, rubert-tiny2, rubert-tiny, FT_geowac_21mb, и Hashing_1000_char обладают наилучшим качеством для своего размера.Картинка ниже показывает, в каком смысле каждая из этих моделей оптимальна.Баланс производительности и качества разных моделейВ большинстве приложений лимитирующим фактором является скорость на CPU; поэтому для них в качестве энкодеров предложений можно рекомендовать использовать MUSE (если главное качество), FastText (если очень важна скорость), либо rubert-tiny2 (если хочется компромисса).И что теперьЕсли вы хотите использовать готовый энкодер предложений, и не знаете, какой выбрать, в readme репозитория – лидерборд. Наверное, я буду его время от времени обновлять. Выбирайте тот баланс качества и производительности, какой нравится. А если не хочется думать, используйте rubert-tiny2 (:Если в лидерборде нет задачи, похожей на ту, которую вы хотите решить – пишите в issue, и я включу эту задачу туда. Для бенчмарка это окей – быть динамическим. Если вы нашли новый энкодер для русских предложений или даже обучили свой собственный, и хотите его протестировать на моём бенчмарке – вот пример кода. Либо опять таки пишите issue, и я перезапущу бенчмарк с вашей моделью. Ну напоследок стандартное: подписывайтесь на мой канал, вступайте в чат по NLP, создавайте полезные ресурсы, и не нападайте на соседние страны. И вообще ни на кого не нападайте!P.S. Вчера коллеги указали на не использованный мною источник: мультиязычные модели из проекта sentence-transformers. Я добавил их в бенчмарк, и они сразу вылезли в топ лидерборда. Актуальный лидерборд смотрите в репозитории: https://github.com/avidale/encodechka.Обновлённый лидерборд с более качественными мультиязычными моделями     Tags: sentence encoderэнкодер предложенийbertбенчмаркбенчмаркинг Hubs: PythonSemanticsMachine learningNatural Language Processing          


