

Семантические технологии просто и доступно на примере родословных / Habr


              16  November  2015 at 23:53  Семантические технологии просто и доступно на примере родословных Python *Semantics *Data Mining *Algorithms *Data visualization * 
        Tutorial
           Программа, способная к логическим выводам в рамках поставленной задачи, может казаться техническим чудом и воплощением Скайнета. Но, как можно убедиться ниже, на сегодняшний день создать такую программу на языке Python не составит труда, если использовать семантические технологии. Мы остановимся на наглядном примере онтологий — родословных — и для любого члена семьи в родословной сможем выводить его родственные отношения произвольной сложности (она ограничена вычислительными ресурсами). К примеру, на фамильном древе семьи Романовых ниже показан внучатый двоюродный племянник (first cousin twice removed) российского императора Петра II.




Так что если вы хотите познакомиться с технологиями семантического веба на практике, добро пожаловать под кат, где мы потренируемся на кошках на родословных.


О триплетах, RDF и онтологиях можно прочесть в википедии или в других постах. Для описания семейных связей в родословных мы задействуем OWL 2 онтологию Family History Knowledge Base (FHKB). Заметим, что авторы FHKB хотя и признают своё детище хорошим учебным примером, всё же не рекомендуют OWL 2 к использованию в реальных генеалогических приложениях из-за вычислительной сложности для сегодняшних систем рассуждений. Наше же приложение останется учебным: мы ограничимся небольшими генеалогиями до ста членов семей.


Генеалогические данные обычно доступны в текстовом формате GEDCOM (.ged). Некоторые генеалогические порталы и программы по ведению родословных позволяют выгружать графы связей в этом формате. Мы прочитаем GEDCOM при помощи одноимённой библиотеки для языка Python и сгенерируем триплеты индивидуумов (так называемый ABox) для онтологии FHKB. Логика (TBox) для выведения родственных связей у нас уже имеется, и всё, что нам нужно сделать — это задать данные, к которым эта логика будет применяться.


Представим, что у нас есть данные для следующих трёх индивидуумов (абстрактно), на примере вышеупомянутой семьи русских царей:

Александр I *есть-брат* Николая I.
Николай I *есть-отец* Александра II.



и логика FHKB:

Свойство *есть-дядя* является последовательностью свойств *есть-брат* и *есть-отец*.



Тогда система рассуждений в состоянии установить следующий факт:

Александр I *есть-дядя* Александра II.



Эта же информация на RDF-наречии Turtle ниже. Оно компактно и довольно легко читается:

fhkb:i1 a owl:NamedIndividual ;
    fhkb:isBrotherOf fhkb:i2 ;
    rdfs:label "Александр I" .
fhkb:i2 a owl:NamedIndividual ;
    fhkb:isFatherOf fhkb:i3 ;
    rdfs:label "Николай I" .
fhkb:i3 a owl:NamedIndividual ;
    rdfs:label "Александр II" .
fhkb:isFatherOf a owl:ObjectProperty ;
    rdfs:label "есть-отец" .
fhkb:isBrotherOf a owl:ObjectProperty ;
    rdfs:label "есть-брат" .
fhkb:isUncleOf a owl:ObjectProperty ;
    owl:propertyChainAxiom ( fhkb:isBrotherOf fhkb:isFatherOf ) ;
    rdfs:label "есть-дядя" .



(Примечание: здесь опущены некоторые детали для наглядности. В оригинальной FHKB свойства isFatherOf, isBrotherOf и isUncleOf определены несколько иначе для оптимизации логических рассуждений.)


Итак, мы задали индивидуумов i1, i2 и i3, свойства isFatherOf и isBrotherOf, назначили эти свойства индивидуумам и ввели новое свойство isUncleOf. Обратим внимание на префиксы rdfs:, owl: и fhkb: — они показывают задействованные области знаний. Префикс rdfs: указывает на стандартную схему RDF (в примере выше это свойство label). Префикс owl: указывает на стандартные онтологические термины (индивидуум, свойство, последовательность свойств и т.д.). А префикс fhkb: — это используемая нами генеалогическая онтология FHKB, где определена логика родственных связей (isFatherOf, isBrotherOf, isUncleOf, а также другие термины, isGrandfatherOf, isFirstCousinOf и т.д.).


Для каждого индивидуума нам достаточно взять из GEDCOM только минимальную информацию об отцовстве (материнстве), братьях, сёстрах и браках (по сути, GEDCOM больше ничего и не содержит), все остальные родственные связи, логика для которых нам дана в FHKB, будут выведены системой рассуждений.




Итак, логическая база (TBox) доступна в Turtle-файле header.ttl из репозитория для этой статьи. Генеалогия царской семьи Романовых в GEDCOM тоже присутствует, но читателю рекомендуется взять свою для интереса. А вот и скрипт, который сгенерирует индивидуумов для онтологии FHKB из GEDCOM-файла: gedcom2ttl.py. (После клонирования репозитория необходимо установить Python-зависимости при помощи команды pip install -r requirements.txt.) Скопируем FHKB-логику header.ttl в новый файл и дозапишем в него результат работы скрипта:

cp data/header.ttl romanov_family.ttl
./gedcom2ttl.py data/tsars.ged >> romanov_family.ttl



В результате у нас получилась онтология (TBox+ABox) в формате Turtle, которую можно открыть в любом внешнем редакторе (например, Prot