

Обработка текстов на естественных языках / Habr


                18  May  2018 at 10:31  Обработка текстов на естественных языках VK corporate blog Data Mining *Machine learning *Natural Language Processing *      

Сегодня мы затрагиваем такую интересную тему, как естественные языки. Сейчас в эту область вкладываются очень большие деньги и в ней решают немало разнообразных задач. Она привлекает внимание не только индустрии, но и научного сообщества.

Может ли машина думать? 

Исследователи связывают анализ естественных языков с принципиальным вопросом: может ли машина мыслить? Известный философ Рене Декарт давал однозначно отрицательный ответ. Неудивительно, учитывая уровень развития техники XVII века. Декарт полагал, что машина не умеет и никогда не научится думать. Машина никогда не сможет общаться с человеком с помощью естественной речи. Даже если мы объясним ей, как использовать и произносить слова, это всё равно будут заученные фразы, стандартные ответы — машина за их рамки не выйдет.

Тест Тьюринга

С тех пор прошло много лет, техника достаточно сильно изменилась, и в XX веке этот вопрос снова обрёл актуальность. Известный учёный Алан Тьюринг в 1950 году усомнился в том, что машина не может мыслить, и для проверки предложил свой знаменитый тест.


Идея теста, по легенде, основана на игре, которую практиковали на студенческих вечеринках. Два человека из компании — парень и девушка — уходили в разные комнаты, а оставшиеся люди общались с ними с помощью записок. Задача игроков заключалась в том, чтобы угадать, с кем же они имеют дело: с мужчиной или с женщиной. А парень с девушкой притворялись друг другом, чтобы ввести остальных игроков в заблуждение. Тьюринг сделал достаточно простую модификацию. Он заменил одного из скрытых игроков компьютером и предложил участникам распознать, с кем они взаимодействуют: с человеком или с машиной.




Тест Тьюринга был придуман уже больше полувека назад. Программисты не раз заявляли, что их детище прошло тест. Каждый раз возникали спорные требования и вопросы, действительно ли это так. Официальной достоверной версии, справился ли кто-то с основным тестом Тьюринга, нет. Некоторые из его вариаций на самом деле были успешно пройдены.

Джорджтаунский эксперимент

В 1954 году прошёл Джорджтаунский эксперимент. В его рамках демонстрировалась система, которая автоматически перевела 60 предложений с русского языка на французский. Организаторы были уверены, что всего за три года достигнут глобальной цели: полностью решат проблему машинного перевода. И с треском провалились. Через 12 лет программу закрыли. Никто и близко не смог подойти к решению этой задачи.


С современной позиции можно сказать: основная проблема состояла в малом количестве предложений. В таком варианте задачу решить почти невозможно. А если бы экспериментаторы проводили опыт на 60 тысячах или, может быть, даже на 6 миллионах предложений, тогда у них был бы шанс.

Первые чат-боты

В 1960-е годы появились первые чат-боты, очень примитивные: в основном они перефразировали то, что говорил им собеседник-человек. Современные чат-боты недалеко ушли от своих прародителей. Даже знаменитый чат-бот Женя Густман, который, как считается, прошёл одну из версий теста Тьюринга, сделал это не благодаря хитрым алгоритмам. Куда больше помогло актёрское мастерство: авторы хорошо продумали его личность.

Формальные онтологии, теория грамматик Хомского

Дальше наступила эпоха формальных методов. Это был глобальный тренд. Учёные пытались всё формализовать, построить формальную модель, онтологию, понятия, связи, общие правила синтаксического разбора и универсальную грамматику. Тогда возникла теория грамматик Хомского. Всё это выглядело очень красиво, но так и не дошло до адекватного практического применения, потому что требовало много кропотливой ручной работы. Поэтому в 1980-е годы внимание переключилось на систему другого класса: на алгоритмы машинного обучения и так называемую корпусную лингвистику. 

Машинное обучение и корпусная лингвистика

В чём основная идея корпусной лингвистики? Мы собираем корпус — коллекцию документов, достаточно крупную, и затем с помощью методов машинного обучения и статистического анализа пытаемся построить систему, которая будет решать нашу задачу.


В 1990-е годы эта область получила очень мощный толчок благодаря развитию Всемирной паутины с большим количеством слабоструктурированного текста, по которому нужно было искать, его требовалось каталогизировать. В 2000-е анализ естественных языков начал применяться уже не только для поиска в Интернете, но и для решения разнообразных задач. Появились крупные датасеты с текстом, много разнообразных инструментов, компании стали вкладывать в это большие деньги. 

Современные тренды

Что происходит сейчас? Основные тренды, которые можно выделить в анализе естественных языков, — это активное использование моделей обучения без учителя. Они позволяют выявить структуру текста, некоторого корпуса без заранее заданных правил. В открытом доступе появилось много больших доступных корпусов разного качества, размеченные и нет. Возникли модели, основанные на краудсорсинге: мы не только пытаемся что-то понять с помощью машины, а подключаем людей, которые за небольшую плату определяют, на каком языке написан текст. В некотором смысле начали возрождаться идеи использования формальных онтологий, но теперь онтологии крутятся вокруг краудсорсинговых баз знаний, в частности баз на основе Linked Open Data. Это целый набор баз знаний, его центр — машиночитаемый вариант «Википедии» DBpedia, который тоже наполняется по краудсорсинговой модели. Люди во всём мире могут туда что-то добавлять.


Лет шесть назад NLP (natural language processing, обработка естественных языков) в основном вбирала в себя техники и методы из других областей, но со временем она стала экспортировать их. Методы, которые развились в области анализа естественных языков, начали с успехом применяться и в других областях. И конечно, куда же без deep learning? Сейчас при анализе естественных языков тоже начинают применять глубокие нейросети, пока что с переменным успехом.


Что же такое NLP? Нельзя сказать, что NLP — это конкретная задача. NLP — это огромный спектр задач разного уровня. По уровню детализации, например, можно разбить их так. 




На уровне сигнала нам нужно преобразовать входной сигнал. Это может быть речь, рукопись, печатный отсканированный текст. Требуется преобразовать его в запись, состоящую из символов, с которыми сможет работать машина.


Дальше идёт уровень слова. Наша задача — понять, что здесь вообще есть слово, провести его морфологический анализ, исправить ошибки, если они есть. Чуть выше — уровень словосочетаний. На нём появляются части речи, которые нужно уметь определять, возникает задача распознавать именованные сущности. В некоторых языках даже задача выделения слов нетривиальна. Например, в немецком языке между словами необязательно стоит пробел, и нам нужно уметь вычленить слова из длинной записи.


Из словосочетаний формируются предложения. Надо их выделить, иногда — провести синтаксический разбор, попробовать сформулировать ответ, если предложение вопросительное, устранить двусмысленность слов, если требуется.


Надо заметить, что эти задачи идут в две стороны: связанные с разбором и с генерацией. В частности, если мы нашли ответ на вопрос, нам нужно создать предложение, которое будет адекватно выглядеть с точки зрения человека, который его прочитает, и отвечать на вопрос.


Предложения группируются в абзацы, и здесь уже возникает вопрос разрешения ссылок и установления отношений между объектами, упомянутыми в разных предложениях.


С абзацами мы можем решать новые задачи: проанализировать эмоциональную окраску текста, определить, на каком языке он написан.


Абзацы формируют документ. На этом уровне работают самые интересные задачи. В частности, семантический анализ (о чём документ?), генерация автоматической аннотации и автоматического summary, перевод и создание документов. Все наверняка слышали об известном генераторе научных статей SCIgen, который создал статью «Корчеватель: Алгоритм типичной унификации точек доступа и избыточности». SCIgen регулярно подвергает испытаниям редакционные коллегии научных журналов.


Но есть задачи, связанные с корпусом в целом. В частности, дедублицировать огромный корпус документов, искать в нём информацию и т. д.

Пример задачи: кому показать пост на OK.RU?

Например, в нашем проекте OK.RU, более известном как «Одноклассники», есть задача ранжирования контента в ленте. Кто-то из ваших друзей или групп делает пост, причём таких постов, как правило, достаточно много, особенно если учесть записи, лайкнутые друзьями. Нам нужно выбрать из множества записей те, что больше всего вам подходят. Какие здесь сложности и возможности?


У нас есть крупный датасет, там уже больше 2 миллиардов постов, за день может появиться несколько миллионов новых. В записях встречается около 40 языков, в том числе достаточно слабо изученные: узбекский, таджикский. В документах очень много шума. Это не новостные и не научные статьи, их пишут простые люди — там есть ошибки, опечатки, сленг, спам, копипаста и дубликаты. Казалось бы, зачем вообще пытаться анализировать контент, если уже есть много методов на основе коллаборативной фильтрации? Но в случае с лентой такие рекомендации работают плохо: здесь постоянно возникает ситуация холодного старта. У нас появился новый объект. Мы ещё почти не знаем, кто и как с ним взаимодействовал, но уже должны решить, кому его показывать, а кому нет. Поэтому применим классический воркэраунд для задачи холодного старта и построим систему контентных рекомендаций: попробуем научить машину понимать, о чём написан пост.

Проблема издалека

Взглянув на проблему с высоты птичьего полёта, выделим основные блоки. Во-первых, корпус многоязыковой, поэтому для начала выясним язык документа. Пользовательский текст содержит опечатки. Соответственно, нужен какой-то корректор опечаток для приведения текста к канонической форме. Чтобы работать с документами дальше, нужно уметь их векторизовать. Поскольку в корпусе много дубликатов, не обойтись без дедубликации. Но самое интересное — мы хотим узнать, о чём этот пост. Соответственно, требуется метод семантического анализа. И мы хотим понять отношение автора к объекту и теме. Тут поможет анализ эмоциональной окраски.

Определение языка

Начнём по порядку. Определение языка. Здесь используются стандартные техники машинного обучения с учителем. Мы делаем некий размеченный корпус по языкам и тренируем классификатор. Как правило, простые статистические классификаторы работают достаточно хорошо. В качестве признаков для этих классификаторов обычно берут N-граммы, т. е. последовательности из N (допустим, трёх) подряд идущих символов. Строят гистограмму распределения последовательностей в документе и на её основании определяют язык. В более продвинутых моделях могут использовать N-граммы другой размерности, а из последних разработок отметим N-граммы переменной длины, или, как назвали их авторы, инфинитиграммы.


Поскольку задача довольно старая, есть немало готовых работающих инструментов. В частности, это Apache Tika, японская библиотека language-detection и одна из последних разработок — питоновский пакет Ldig, который как раз работает на инфинитиграммах.


Эти методы хороши для достаточно крупных текстов. Если есть абзац или хотя бы пятёрка предложений, язык определится с точностью более 99 %. Но если текст короткий, из одного предложения или нескольких слов, то классический подход, основанный на триграммах, очень часто ошибается. Исправить ситуацию могут инфинитиграммы, но это новая область, далеко не для всех языков уже есть обученные и готовые классификаторы.

Приведение к канонической форме

Мы определили язык текста. Нужно привести его к канонической форме. Зачем? Один из ключевых объектов при анализе текста — словарь, и сложность алгоритмов часто зависит от его размеров. Возьмём все слова, которые использовались в вашем корпусе. Скорее всего, это будут десятки, а то и сотни миллионов слов. Если мы посмотрим на них более пристально, то увидим, что на самом деле это не всегда отдельные слова, порой встречаются словоформы или слова, написанные с ошибками. Чтобы уменьшить размер словаря (и вычислительную сложность) и улучшить качество работы многих моделей, приведём слова к канонической форме.


Сначала исправим ошибки и опечатки. В этой области есть два подхода. Первый основан на так называемом фонетическом матчинге. Вот его основная идея. Почему человек ошибается? Потому что пишет слово так, как его слышит. Если мы возьмём верное слово и слово с ошибкой, а потом запишем, как оба слышатся и произносятся, то получим один и тот же вариант. Соответственно, ошибка уже не будет влиять на анализ.


Альтернативный подход — так называемое редакционное расстояние, с помощью которого мы ищем в словаре максимально похожие слова-аналоги. Редакционное расстояние определяет, сколько операций изменения нужно, чтобы кратчайшим образом превратить одно слово в другое. Чем меньше операций требуется, тем больше слова похожи.


Итак, мы исправили ошибки. Но всё равно в том же русском языке у слова может быть огромное количество корректных словоформ с разнообразными окончаниями, приставками, суффиксами. Это словарь достаточно сильно взрывает. Нужно привести слово к основной форме. И здесь есть две концепции.


Первая концепция — стемминг, мы пытаемся найти основу слова. Можно сказать, что это корень, хотя лингвисты могут поспорить. Здесь используется подход affix stripping. Основная идея в том, что мы отрезаем от слова по кусочку и с конца, и с начала. Удаляем окончания, приставки, суффиксы, и в итоге как раз остаётся основная часть. Есть известная реализация, так называемый стеммер Портера, или проект Snowball. Основная проблема подхода: правила для стеммера устанавливают лингвисты, и это достаточно тяжёлый труд. Перед подключением нового языка нужны лингвистические исследования.


Есть разновидности подхода. Мы можем или просто делать lookup по словарю, или строить supervised-модели без учителя, опять же — вероятностные модели на основе скрытых цепей Маркова, или обучать нейросети, которые приведут слова в редуцированную форму.


Стемминг используется достаточно давно. В Google — с начала 2000-х. Самый распространённый, наверное, инструмент — реализация в пакете Apache Lucene. Но у стемминга есть недостаток. Когда мы урезаем слово до основы, мы лишаемся части информации. Потому что у нас остаётся лишь корень, и мы можем потерять данные о том, было ли это прилагательное или существительное. И иногда это важно для постановки дальнейших задач.


Вторая концепция, альтернатива стемминга — лемматизация. Она пытается привести слово не к основе или корню, а к базовой, словарной форме — т. е. лемме. К примеру, глагол — к инфинитиву. Существует множество реализаций, и тема очень хорошо проработана именно для user generated текстов, пользовательски зашумлённых текстов. Однако приведение в каноническую форму по-прежнему остаётся сложной и до конца не решённой задачей. 

Векторизация

Привели к канонической форме. Теперь отобразим это в векторном пространстве, потому что почти все математические модели работают в векторных пространствах больших размерностей. Базовый подход, который используют многие модели, — метод "мешка слов". Мы формируем для документа вектор в пространстве, размерность которого равна размеру нашего словаря. Для каждого слова выделена своя размерность, и для документа мы записываем признак, насколько часто это слово в нём использовалось. Получаем вектор. Есть много подходов к тому, как его выяснить. Доминирует так называемый TF-IDF. Частоту слова (term frequency, TF) определяют по-разному. Это может быть счётчик вхождения слова. Или флаг, видели мы слово либо нет. Или что-то чуть более хитрое, например логарифмически сглаженное количество упоминаний слова. И вот что самое интересное. Определив TF в документе, мы перемножаем её с обратной частотой документа (inverse document frequency, IDF). IDF обычно вычисляют как логарифм от числа документов в корпусе, разделённый на количество документов, где это слово представлено. Вот пример. У нас встретилось слово, которое употреблялось во всех-всех-всех документах корпуса. Очевидно, логарифм даст нам ноль. Такое слово мы никуда не добавим: оно не несёт никакой информации, оно есть во всех документах.


В чём преимущество подхода мешка слов? Его просто реализовать. Но он теряет часть информации, в том числе сведения о порядке слов. И сейчас продолжают ломать много копий на тему того, насколько важен порядок слов. У нас есть один известный пример — магистр Йода. Он расставляет слова в предложении хаотично. Речь Йоды необычна, но мы её свободно понимаем: т. е. человеческий мозг достаточно легко восстанавливает информацию даже при потерянном порядке.


Но иногда эта информация значима. Например, при анализе эмоциональной окраски очень важно, к чему относилось, условно говоря, слово «хороший» или «нет». Тогда наряду с мешком слов поможет мешок N-грамм: мы добавляем в словарь не только слова, но и словосочетания. Мы не будем вносить все словосочетания, потому что это приведёт к комбинаторному взрыву, но часто используемые статистически значимые пары или пары, соответствующие именованным сущностям, можно добавить, и это повысит качество работы итоговой модели.


Другой пример ситуации, когда «мешок слов» может терять или искажать информацию — слова синонимы или слова со несколькими различными смыслами (например, замок). Отчасти эти ситуации позволяют обработать методы построения "векторных представлений слов", например, знаменитый word2vec или более модные skip-gramm.

Дедубликация

Векторизовали. Теперь почистим корпус от дубликатов. Принцип понятен. У нас есть векторы в векторном пространстве, мы можем определить их близость, взять косинус, можем другие метрики близости, но обычно используют именно косинус. Объединим в общую группу документы, где косинус близок к единице.


Казалось бы, всё просто, понятно, но есть одно но: у нас 2 миллиарда документов. Если мы умножим 2 миллиарда на 2 миллиарда, то никогда не закончим считать косинусы. Нужна оптимизация, которая позволит быстро выбрать кандидатов для расчета косинуса, избавившись от полного перебора. И здесь поможет локально-чувствительный хеш. Стандартные хеш-функции равномерно размазывают данные по пространству хешей. Локально-чувствительный хеш похожие объекты поместит в пространстве объектов близко. С какой-то вероятностью он вообще может дать им один и тот же хеш.


Есть много техник подсчёта локально-чувствительного хеша под разные метрики похожести. Если речь идёт о косинусе, то часто используется метод случайных проекций. Мы выбираем случайный базис из случайных векторов. Считаем косинус нашего документа с одним из векторов базиса. Если он больше нуля, то ставим единичку. Меньше нуля или равен ему — ставим ноль. Дальше сравниваем со вторым вектором базиса, получаем ещё один нолик или единичку. Сколько у нас векторов в базисе — столько мы в итоге получаем битов, и это наш хеш.


В чём преимущество, почему это вообще работает? Если два документа близки по косинусу друг с другом, то с высокой вероятностью они окажутся по одну и ту же сторону от вектора базиса. Поэтому у похожих документов хеш с высокой вероятностью окажется один. Тем не менее выбросы будут. Чтобы их исправить, мы просто повторим процедуру. На практике мы обычно используем два прогона. На первом вычисляем 24-битный хеш и удаляем много почти идентичных документов. Дальше считаем ещё один хеш на другом базисе, но уже в 16 бит и довычищаем дубликаты. После этого копий не остаётся — либо же их настолько мало, что они не могут значимо отразиться на качестве работы моделей.

Семантический анализ

И потихоньку переходим к самому интересному. Как же нам понять, о чём документ? Задача семантического анализа достаточно старая. Олдскульный подход такой: делаем заранее описанную онтологию, строгий синтаксический разбор, мепим узлы синтаксического дерева к понятиям в нашей онтологии, делаем много рукописных правил — и т. д., в итоге получаем семантику. Всё это красиво теоретически, но на практике не действует: там, где рукописных правил множество, работать тяжело.


Современный подход — анализ семантики без учителя, поэтому его называют анализом скрытой (латентной) семантики. Этот метод (или даже семейство методов) хорошо работает на крупных корпусах — запускать поиск скрытой семантики имеет смысл только на большом корпусе. Там, как правило, относительно мало параметров, которые можно потюнить, в отличие от простыней с правилами в олдскульных подходах, и есть готовые инструменты: бери и пользуйся.

Латентно-семантический индекс

Исторически первый подход к латентно-семантическому анализу — это латентно-семантическое индексирование. Идея очень простая. Мы уже использовали для решения задач коллаборативных рекомендаций хорошо зарекомендовавшие себя техники факторизации матриц.




В чём суть факторизации? У нас есть большая матрица, в рекомендациях это user — item (насколько юзеру нравится айтем). Мы её разбиваем на произведения маленьких матриц. Теперь у нас получилась матрица факторов юзеров и факторов айтемов. Потом мы берём эти две матрицы (user — factor и factor — item) и перемножаем. Получаем новую матрицу user — item. Она, если мы правильно провели факторизацию, максимально точно соответствует матрице, которую мы изначально раскладывали. То же самое можно сделать и с документами. Берём матрицу «документ — слово» или «слово — документ» и раскладываем на произведение двух матриц: «документ — фактор» и «фактор — слово». Всё просто, есть готовые инструменты. При таком подходе мы автоматически учитываем слова с разнообразными смыслами, синонимы. Если в корпусе много опечаток, мы всё равно поймём, что неправильно написанное слово относится к такому-то скрытому фактору. Минимум параметров, готовые инструменты. Уже с начала 1990-х этими техниками пользовались. Есть только одно но: полученная семантика слишком скрытая. По векторам факторов документов и факторов слов очень сложно что-нибудь сказать о корпусе. Если в задачах коллаборативных рекомендаций эта проблема не настолько важна, то при анализе естественных языков во многих задачах дело обстоит иначе. Математическая модель, которую мы не в силах интерпретировать, не даёт нам новых знаний. Поэтому начали искать альтернативы.

Вероятностный латентно-семантический индекс

Одной из альтернатив стал так называемый вероятностный латентно-семантический индекс. В основе техники лежала очень простая идея.




У нас есть документы. Предположим, что они созданы не просто так, а на основе тем, которые мы ещё не знаем. Попробуем симулировать, как эти документы могли бы быть написаны. У нас есть корпус. Мы выбираем случайный документ, дальше из распределения его тем случайно выбираем тему. Дальше из распределения слов по теме выбираем слово. И вот мы получили одно слово в документе. Потом повторяем (выбрали документ, выбрали тему, сгенерировали слово), пока не сгенерируем все слова в корпусе, во всех документах корпуса.


Чтобы всё функционировало, нужно всего лишь правильно работающее распределение: тем по документу и слов по теме.


Что это, почему оно работает? Важно понять, что техника вероятностного латентно-семантического индекса — это техника факторизации матрицы. От большой матрицы «документ — слово» мы переходим к двум меньшим: «документ — тема» и «тема — слово». После перемножения они генерируют наш корпус, вернее вероятности того, что в корпус что-то попадёт. По сравнению с классической факторизацией на основе сингулярного разложения у вероятностной генерирующей модели есть важное преимущество. Скрытые факторы темы стали интерпретируемыми. Теперь у них есть понятный физический смысл, теперь это часть генерирующего документ процесса, и понять, что за темой стоит, мы, как правило, можем относительно легко: посмотрев, какие слова она генерирует.


Важное отличие техники генерирующей модели — она должна работать уже на голых TF-матрицах. Если натравить её на TF-IDF матрицу, то результат факторизации может быть бессмысленным.


Как мы оценим, насколько модель хороша? Мы получили две матрицы. В стандартной факторизации мы оценивали среднее квадратичное отклонение. Здесь у нас вероятностная модель, и мы пытаемся понять, насколько вероятно, что наблюдаемый нами реально корпус мог быть получен в той модели, которую мы построили. Для этого используется перплексия.




Вдаваться в метрику не будем. Лучше обратим внимание на нижнюю строку: как мы определяем, какова вероятность увидеть конкретное слово в конкретном документе. По сути, это как раз и есть сумма по всем темам произведения вероятности. Выбрать тему для документа и выбрать слово для темы. Вот эти две матрицы нам и нужно подобрать. Распределение «тема — документ» и распределение «слово — тема». Как мы это сделаем? Конечно же, итеративно.


Есть так называемый EM-алгоритм. Он итеративно строит модель, которая оптимизирует перплексию, т. е. увеличивает вероятность того, что наш корпус будет построен нашей моделью. В его основе лежит число 