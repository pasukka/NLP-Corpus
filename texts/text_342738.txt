

RNN: может ли нейронная сеть писать как Лев Толстой? (Спойлер: нет) / Habr


               22  November  2017 at 19:37  RNN: может ли нейронная сеть писать как Лев Толстой? (Спойлер: нет) Python *Data Mining *Machine learning * 
        Tutorial
           При изучении технологий Deep Learning я столкнулся с нехваткой относительно простых примеров, на которых можно относительно легко потренироваться и двигаться дальше.


В данном примере мы построим рекуррентную нейронную сеть, которая получив на вход текст романа Толстого «Анна Каренина», будет генерировать свой текст, чем-то напоминающий оригинал, предсказывая, какой должен быть следующий символ.


Структуру изложения я старался делать такой, чтобы можно было повторить все шаги новичку, даже не понимая в деталях, что именно происходит внутри этой сети. Профессионалы Deep Learning скорее всего не найдут тут ничего интересного, а тех, кто только изучает эти технологии, прошу под кат.

Введение

За основу этого мини-проекта были взяты статьи Andrej Karpathy (ссылки ниже по тексту) и учебные материалы udacity.

Самый простой путь повторить все описанное ниже:


установить у себя на ПК дистрибутив anaconda с версией Python 3.6
создать рабочий conda environment
установить в этот environment библиотеки tensorflow, numpy, jupyter
писать и исполнять код в Jupyter Notebook, что дает нам нужную интерактивность
скачать текст романа в txt формате


В случае инсталляции anaconda на Windows делаем следующее:


1. Создаем папку, в которой будем работать, копируем туда текст под именем «anna.txt»


2. Запускаем Anaconda Promt, переходим в созданную папку, создаем там нужный environment «tolstoy» с необходимыми библиотеками и активируем его:

(C:\anaconda3) C:\DL\rnn-tolstoy>conda create -n tolstoy
...
(C:\anaconda3) C:\DL\rnn-tolstoy>activate tolstoy
(tolstoy) C:\DL\rnn-tolstoy>conda install numpy tensorflow jupyter
...

3. Когда все библиотеки установятся, запускаем jupyter notebook, в котором будем работать:

(tolstoy) C:\DL\rnn-tolstoy>jupyter notebook

4. В браузере открывается меню notebook, там идем в «New» и выбираем Notebook -> Python 3, как показано на картинке:




После чего открывается уже сам notebook, где мы будем вбивать код и любоваться результатом его работы. Например, вбив код в ячейку «In», мы можем его выполнить нажатием Shift+Enter и сразу получить результат:




К этому моменту мы разобрались с базовыми вещами, теперь можно приступать к самой задаче.

Ниже приведена общая архитектура рекуррентной нейронной сети (RNN), предсказывающей следующий символ (взято отсюда):




На схеме видна ключевая особенность RNN — информация может обрабатываться циклично при движении от input к output, обеспечивая (в отличие от традиционных нейронных сетей) эффект памяти и позволяя обрабатывать связанные последовательности.

Инициализируем и готовим данные

Импортируем нужные библиотеки:

import time
from collections import namedtuple
import numpy as np
import tensorflow as tf

Загружаем текст романа, создаем словарь символов vocab, объекты dictionary для трансляции символ -> код, код -> символ и кодируем весь текст романа (массив encoded):

with open('anna.txt', 'r') as f:
    text=f.read()
vocab = sorted(set(text))
vocab_to_int = {c: i for i, c in enumerate(vocab)}
int_to_vocab = dict(enumerate(vocab))
encoded = np.array([vocab_to_int[c] for c in text], dtype=np.int32)

Проверяем начало, знаменитая фраза на месте, все в порядке:

text[:110]
Out: 'ЧАСТЬ ПЕРВАЯ\n\n\n\nI\n\nВсе счастливые семьи похожи друг на друга, каждая несчастливая семья несчастлива по-своему.'

Смотрим, как это выглядит в закодированном виде (именно в таком виде данные будут обрабатываться в сети):

encoded[:110]
Out:
array([ 99,  77,  93,  94, 102,   1,  91,  82,  92,  79,  77, 105,   0,
         0,   0,   0,  30,   0,   0,  79, 123, 111,   1, 123, 129, 106,
       123, 124, 117, 114, 108, 133, 111,   1, 123, 111, 118, 134, 114,
         1, 121, 120, 127, 120, 112, 114,   1, 110, 122, 125, 109,   1,
       119, 106,   1, 110, 122, 125, 109, 106,   7,   1, 116, 106, 112,
       110, 106, 137,   1, 119, 111, 123, 129, 106, 123, 124, 117, 114,
       108, 106, 137,   1, 123, 111, 118, 134, 137,   1, 119, 111, 123,
       129, 106, 123, 124, 117, 114, 108, 106,   1, 121, 120,   8, 123,
       108, 120, 111, 118, 125,   9])

Поскольку наша сеть работает с отдельными символами, мы имеем дело с проблемой классификации, когда мы пытаемся предсказать следующий символ из предыдущего текста. Длина словаря это по сути количество классов, из которых наша сеть будет делать выбор:

len(vocab)
Out: 140


Символов в словаре многовато, но нужно учитывать, что заглавные и строчные буквы — это разные символы, а также помним про большое количество текста на французском, т.е. у нас по сути два алфавита.

Делим данные на пакеты

Для эффективного обучения нашей сети необходимо разбить данные на пакеты (mini-batches). Во-первых это экономит оперативную память. Если мы попытаемся загнать в сеть все данные целиком за один раз, памяти может просто не хватить. Во-вторых при дроблении данных на пакеты сеть будет обучаться значительно быстрее — мы можем обновлять веса в нейронной сети после прохождения каждого пакета данных, а также параллелить загрузку пакетов, как показано на картинке:




Создаем процедуру получения исходного пакета, который будет подаваться на вход нейронной сети (feature) и контрольного пакета, с которым будет сравниваться предсказание сети (target):

def get_batches(arr, n_seqs, n_steps):
    '''Создаем генератор, который возвращает пакеты размером
       n_seqs x n_steps из массива arr.
       
       Аргументы
       ---------
       arr: Массив, из которого получаем пакеты
       n_seqs: Batch size, количество последовательностей в пакете
       n_steps: Sequence length, сколько "шагов" делаем в пакете
    '''
    # Считаем количество символов на пакет и количество пакетов, которое можем сформировать
    characters_per_batch = n_seqs * n_steps
    n_batches = len(arr)//characters_per_batch
    
    # Сохраняем в массиве только символы, которые позволяют сформировать целое число пакетов
    arr = arr[:n_batches * characters_per_batch]
    
    # Делаем reshape 1D -> 2D, используя n_seqs как число строк, как на картинке
    arr = arr.reshape((n_seqs, -1))
    
    for n in range(0, arr.shape[1], n_steps):
        # пакет данных, который будет подаваться на вход сети
        x = arr[:, n:n+n_steps]
        # целевой пакет, с которым будем сравнивать предсказание, получаем сдвиганием "x" на один символ вперед
        y = np.zeros_like(x)
        y[:, :-1], y[:, -1] = x[:, 1:], x[:, 0]
        yield x, y

Функция работает как генератор, каждое обращение к которому позволяет получить следующую пару «x» и «y», например:

batches = get_batches(encoded, 10, 50)
x, y = next(batches)
print('x\n', x[:5, :5])
print('\ny\n', y[:5, :5])
x
 [[ 99  77  93  94 102]
 [  1 110 108 114 112]
 [ 79 120 124   1 120]
 [114 119   1 109 120]
 [106 108 111 110 117]]
y
 [[ 77  93  94 102   1]
 [110 108 114 112 111]
 [120 124   1 120 124]
 [119   1 109 120 108]
 [108 111 110 117 114]]

В выводе виден сдвиг пакета «y» по отношению к пакету «х».

Строим модель

Ниже приведена схема нашей RNN модели:




Основная магия обучения происходит в ячейке LSTM (Long Short Term Memory).

Вот здесь лежит замечательная статья, в которой простым и понятным английским языком описывается логика работы таких ячеек и нейронных сетей, основанных на LSTM. 


При построении модели сначала определяем входящие параметры: 

def build_inputs(batch_size, num_steps):
    ''' Определяем placeholder'ы для входных, целевых данных, а также вероятности drop out
    
        Аргументы
        ---------
        batch_size: Batch size, количество последовательностей в пакете
        num_steps: Sequence length, сколько "шагов" делаем в пакете
        
    '''
    # Объявляем placeholder'ы
    inputs = tf.placeholder(tf.int32, [batch_size, num_steps], name='inputs')
    targets = tf.placeholder(tf.int32, [batch_size, num_steps], name='targets')
    
    # Placeholder для вероятности drop out
    keep_prob = tf.placeholder(tf.float32, name='keep_prob')
    
    return inputs, targets, keep_prob

Надо напомнить, что данные в Tensorflow хранятся в тензорах.

"placeholder'ы" — вид тензоров, который определяет тип и формат данных (например размерность матрицы), а сами данные реально будут загружены в нужный момент в будущем.

Что касается drop out — это механизм противодействия эффекту «переобучения» нашей сети, когда в процессе мы случайным образом исключаем часть вершин нашего графа из расчетов:




Дальше мы строим структуру LTSM ячейки. 

def build_lstm(lstm_size, num_layers, batch_size, keep_prob):
    ''' Строим LSTM ячейку.
    
        Аргументы
        ---------
        keep_prob: Скаляр (tf.placeholder) для dropout keep probability
        lstm_size: Размер скрытых слоев в LSTM ячейках
        num_layers: Количество LSTM слоев
        batch_size: Batch size
    '''
    ### Строим LSTM ячейку
    
    def build_cell(lstm_size, keep_prob):
        # Начинаем с базовой LSTM ячейки
        lstm = tf.contrib.rnn.BasicLSTMCell(lstm_size)
        
        # Добавляем dropout к ячейке
        drop = tf.contrib.rnn.DropoutWrapper(lstm, output_keep_prob=keep_prob)
        return drop
    
    
    # Стэкируем несколько LSTM слоев для придания глубины нашему deep learning
    cell = tf.contrib.rnn.MultiRNNCell([build_cell(lstm_size, keep_prob) for _ in range(num_layers)])
    # Инициализируем начальное состояние LTSM ячейки
    initial_state = cell.zero_state(batch_size, tf.float32)
    
    return cell, initial_state

Далее будем строить выходной слой. Определяемся с размерностью.

Если входные данные имели размерность M (batch size), N (sequence length) и проходили через скрытые слои размером L юнитов, то на выходе получаем 3D тензор размерностью MxNxL. Чтобы упростить задачу, сделаем reshape 3D -> 2D и приведем тензор к виду (M