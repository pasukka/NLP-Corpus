

Нейросети для Natural Language Inference (NLI): логические умозаключения на русском языке / Habr


              10  October  2021 at 15:35  Нейросети для Natural Language Inference (NLI): логические умозаключения на русском языке Python *Semantics *Programming *Machine learning *Natural Language Processing *      NLI (natural language inference) – это задача автоматического определения логической связи между текстами. Обычно она формулируется так: для двух утверждений A и B надо выяснить, следует ли B из A. Эта задача сложная, потому что она требует хорошо понимать смысл текстов. Эта задача полезная, потому что "понимательную" способность модели можно эксплуатировать для прикладных задач типа классификации текстов. Иногда такая классификация неплохо работает даже без обучающей выборки! До сих пор в открытом доступе не было нейросетей, специализированных на задаче NLI для русского языка, но теперь я обучил целых три: tiny, twoway и threeway. Зачем эти модели нужны, как они обучались, и в чём между ними разница – под катом.Модели NLI можно применять и для логического вывода, и для классификации текстовЗадача NLIНа русский язык понятие natural language inference можно перевести как логический вывод (или умозаключения) на естественном языке. Обычно эта задача формулируется как классификация пары текстов на два класса (entailment/not_entailment) или на три класса (entailment/contradiction/neutral). Выглядят классы примерно так:из "Петя – хакер" следует, что  "Петя – айтишник", ибо нам известно, что все хакеры – айтишники. Это entailment.из "Петя – хакер" не следует "Петя – кот", более того, второе утверждение противоречит первому, потому что хакерами вроде как бывают только люди, но не коты. Это contradiction.из "Петя – козёл" не следует, что "Вася тоже хакер", но и противоречия между этими утверждениями нет. Это отношение зовётся neutral.В задаче NLI левый текст обычно называется предпосылкой (premise), а правый – гипотезой (hypothesis), и я буду придерживаться такой же терминологии.Чтобы правильно делать подобные суждения, модель должна уметь очень много. Она должна знать слова ("хакер", "кот") и связи между ними ("хакеры – айтишники", "айтишники – люди", "коты – не люди"). Должна уметь в логические операции (отрицания, и/или, если/то, каждый/некоторый и т.п.). Должна понимать природу сущностей ("Швеция – это страна").  Должна понимать, как связаны друг с другом отношения между сущностями (если существует "Король Швеции", то "Швеция – это королевство"). Более подробно про эти умения можно почитать на сайте RussianSuperGLUE, но уже и так понятно, что модель должна очень хорошо понимать смысл текстов. За последние несколько лет появилось много нейросетей типа BERT, предобученных так, что базовое понимание языка у них уже неплохое, в том числе и ряд моделей для русского языка. При обучении двух из них (rubert-base-cased-sentence от DeepPavlov и sbert_large_nlu_ru от SberDevices) даже использовались датасеты NLI, переведённые на русский язык. Но обе они устроены так, что сначала обрабатывают каждый текст по отдельности, а потом сравнивают между собой уже абстрактные представления (точнее, sentence embeddings) этих текстов. Если же модель читает оба текста одновременно, при необходимости "подглядывая" механизмом внимания из одного текста в другой (это называется cross-encoder), она имеет больше шансов понять, как связаны друг с другом смыслы этих текстов. Именно такие модели я и обучил. ПрименениеЗадача NLI важна для компьютерных лингвистов, ибо она позволяет детально рассмотреть, какие языковые явления данная модель понимает хорошо, а на каких – "плывёт"; по этому принципу устроены диагностические датасеты SuperGLUE и RussianSuperGLUE. Кроме этого, модели NLI обладают прикладной ценностью по нескольким причинам.Во-первых, NLI можно использовать для контроля качества генеративных моделей. Есть масса задач, где на основе текста X нужно сгенерировать близкий к нему по смыслу текст Y: суммаризация, упрощение текстов, перефразирование, перенос стиля на текстах, текстовые вопросно-ответные системы, и даже машинный перевод. Современные seq2seq нейросети типа T5 (которая в этом году появилась и для русского языка) в целом неплохо справляются с такими задачами, но время от времени лажают, упуская какую-то важную информацию из Х, или, наоборот, дописывая в текст Y что-то нафантазированное "от себя". С помощью модели NLI можно проверять, что из X следует Y (то есть в новом тексте нету "отсебятины", придуманной моделью), и что из Y следует X (т.е. вся информация, присутствовавшая в исходном тексте, в новом также отражена).  Во-вторых, с помощью моделей NLI можно находить нетривиальные парафразы и в целом определять смысловую близость текстов. Для русского языка уже существует ряд моделей и датасетов по перефразированию, но кажется, что можно сделать ещё больше и лучше. В статье Improving Paraphrase Detection with the Adversarial Paraphrasing Task предложили считать парафразами такую пару предложений, в которой каждое логически следует из другого – и это весьма логично. Поэтому модели NLI можно использовать и для сбора обучающего корпуса парафраз (и не-парафраз, если стоит задача их детекции), и для фильтрации моделей, генерирующих парафразы.В-третьих, NLI можно переиспользовать для задачи классификации текстов с небольшим числом обучающих примеров или даже вообще без обучающей выборки. В статье Entailment as Few-Shot Learner модель, обученную на задаче NLI, дообучали буквально на 8 примерах на новые задачи классификации текстов, и в результате модель справлялась с ними весьма неплохо; в других работах этот подход демонстрировали вообще без дообучения (хотя с этим и обнаружены проблемы). Работает это так: для текста, который надо классифицировать, готовится несколько выводов соответствующих разным, и выбирается самый правдоподобный из них. Например, так можно решить задачу анализа тональности текста:# !pip install transformers sentencepiece
from transformers import pipeline
p = pipeline(
  task='zero-shot-classification', 
  model='cointegrated/rubert-base-cased-nli-twoway'
)
p(
  sequences="Сервис приличный, кормили вкусно", 
  candidate_labels="Мне понравилось, Мне не понравилось", 
  hypothesis_template="{}."
)
# {'labels': ['Мне понравилось', 'Мне не понравилось'],
#  'scores': [0.9580550789833069, 0.0419449619948864],
#  'sequence': 'Сервис приличный, кормили вкусно'}Здесь модель решила, что из текста отзыва вывод "Мне понравилось." следует с двадцатикратно большей вероятностью, чем вывод "Мне не понравилось", и таким образом классифицировала текст как положительный. Конкретно в этой имплементации (transformers.pipelines) метки классов можно подавать в виде одного полотна текста (через запятую) или как список строк, а аргумент hypothesis_template показывает, в форме какого шаблона эти метки должны подаваться в модель. Классов может быть сколько угодно, например, семь разных тематик, из которых модель правильно выбирает "путешествия":p(
  sequences="Я хочу поехать в Дагестан", 
  candidate_labels="спорт,путешествия,музыка,кино,книги,наука,политика", 
  hypothesis_template="Мои интересы - {}."
)
# {'sequence': 'Я хочу поехать в Дагестан', 
   'labels': ['путешествия', 'спорт', 'политика', 'наука', 'кино', 'музыка', 'книги'], 
   'scores': [0.948, 0.019, 0.007, 0.006, 0.006, 0.005, 0.005]}Лично у меня zero-shot классификация на базе NLI не особо взлетела. Например, на задаче классификации 68 интентов zero-shot классификация на основе NLI с написанными вручную 68 гипотезами для каждого класса отработала хуже, чем метод ближайших соседей на эмбеддингах LaBSE с всего лишь тремя примерами на каждый класс. На задачах классификации тональности и токсичности подход Labse+KNN тоже сравнялся по качеству с NLI+zero-shot на нескольких десятках размеченных примеров.  Поэтому кажется, что zero-shot классификацию стоит применять только в случаях, когда нет возможности собрать даже небольшую обучающую выборку, и что её качество будет сильно зависеть от выбранных названий классов и от того, какой шаблон используется для гипотез. Поэтому, если есть возможность дообучить свою модель на задачу классификации, лучше дообучайте. Если возможности нет, но есть даже небольшое число размеченных примеров, используйте KNN. А к zero-shot прибегайте только в крайних случаях.Впрочем, несмотря на свою относительную бесполезность, zero-shot классификация – это всё равно очень прикольно.ДатасетыНасколько мне известно, сегодня существует два датасета, посвящённых задаче NLI на русском языке: TERRa, собранная из русскоязычных публикаций и вручную размеченная, и XNLI, где английские размеченные тексты были переведены на русский и ряд других языков. Оба эти датасета не очень большие, зато на английском языке существуют буквально миллионы размеченных пар текстов. Поэтому в качестве обучающей выборки я использовал в основном корпусы, машинно переведённые с английского языка. Большинство из них было взято из репозитория Felipe Salvatore.Add-one RTE: корпус, в котором в текст добавляется одно слово, которое может поменять или не поменять его смысл. Например, "вселенная" и "вся вселенная" идентичны по смыслу, а "вселенная" и "воображаемая вселенная" – разные. ANLI: три корпуса, собранные вручную таким образом, чтобы с примерами из них плохо справлялись уже имеющиеся продвинутые NLI модели.CoPA: корпус, в котором модель должна догадываться о возможных причинах и следствиях событий.NLI-style FEVER: корпус, проверяющий, есть ли в данном источнике подтверждение данного факта.HELP: автоматически созданный корпус, требующий работы со значениями слов и логикой.IMPPRES: автоматически сгенерированный датасет, анализирующий допущения, неявно подразумеваемые в тексте.IIE: корпус из статьи"Inference is everything", представляющий в форме NLI другие лингвистические задачи: определение семантических ролей, понимание контекстных парафраз, и расшифровка местоимений.JOCI: корпус, фокусирующийся на применении "здравого смысла" (common sense).MNLI: большой многожанровый корпус, собранный из разнообразных устных и письменных источников.MoNLI: корпус, фокусирующийся на отношении "частное/общее". MPE: корпус, где вывод нужно сделать на основе не одной, а множества предпосылок.SCITAIL: корпус вопросов на научную тематику, собранный из экзаменов и интернета.SICK: корпус, ориентированный на понимание того, как смысл фразы складывается из отдельных слов. SNLI: огромный корпус подписей к картинкам, первый крупномасштабный датасет для задачи NLI. TERRa: единственный корпус, который не пришлось переводить на русский.Переведённые тексты я объединил в общий корпус. Для большинства корпусов я использовал готовую train/dev/test разбивку (хотя во многих из них test часть была скрыта), а остальные разбил сам. Для обучения двухклассовых моделей (entailment/not_entailment) я использовал все корпусы (1.6 миллиона обучающих примеров), а для трёхклассовой (entailment/contradiction/neutral) – только ANLI, NLI-style FEVER, IMPPRES.JOCI, MNLI, MPE, SICK, SNLI (1.3 миллиона).МоделиНа собранном мною датасете я обучил три модели (доступен блокнот с обучением и оценкой). Модель cointegrated/rubert-base-cased-nli-threeway обучалась разделять все три класса, а модели cointegrated/rubert-base-cased-nli-twoway и cointegrated/rubert-tiny-bilingual-nli – только отличать entailment от остальных. В моделях threeway и twoway за основу взята нейросеть DeepPavlov/rubert-base-cased размером 700 мб, а в модели tiny – cointegrated/rubert-tiny размером 45 мб. Поэтому версия tiny получилась ожидаемо глупее своих более крупных братьев, но зато и на порядок быстрее. Кроме того, в версии tiny я в 30% случаев подменял русский текст обучающего примера на английский, поэтому она умеет работать с разными комбинациями предпосылки и гипотезы на русском и английском языках.Собственно для NLI модели можно применять примерно так:import torch
from transformers import AutoTokenizer, AutoModelForSequenceClassification
model_checkpoint = 'cointegrated/rubert-base-cased-nli-threeway'
tokenizer = AutoTokenizer.from_pretrained(model_checkpoint)
model = AutoModelForSequenceClassification.from_pretrained(model_checkpoint)
if torch.cuda.is_available():
    model.cuda()
text1 = 'Сократ - человек, а все люди смертны.'
text2 = 'Сократ никогда не умрёт.'
with torch.inference_mode():
    out = model(**tokenizer(text1, text2, return_tensors='pt').to(model.device))
    proba = torch.softmax(out.logits, -1).cpu().numpy()[0]
print(proba)
# [0.00952593 0.9332064  0.05726764]
print({v: proba[k] for k, v in model.config.id2label.items()})
# {'entailment': 0.009525929, 'contradiction': 0.9332064, 'neutral': 0.05726764} Чтобы оценить качество моделей, я рассчитал ROC AUC на dev выборке каждого из доступных датасетов. Для двухклассовых моделей я считал AUC класса entailment, для трёхклассовой – AUC каждого из классов. Кроме этого, я добавил в таблицу две мультиязычные NLI модели, понимающие в том числе и русский: xlm-roberta-large-xnli-anli и bart-large-mnli. modelclassadd_one_rteanli_r1anli_r2anli_r3copafeverhelpiieimppresjocimnlimonlimpescitailsicksnliterratotaln_observations38710001000120020020474335531232766193919647269100021265009831307101128tinyentailment0.770.590.520.530.530.900.810.780.930.810.820.910.810.780.930.950.670.77twowayentailment0.890.730.610.620.580.960.920.870.990.900.900.990.910.960.970.970.870.86threewayentailment0.910.750.610.610.570.960.560.610.990.900.910.670.920.840.980.980.900.80xlm-roberta-large-xnli-anlientailment0.880.790.630.660.570.930.560.620.770.800.900.700.830.840.910.930.930.78bart-large-mnlientailment0.510.410.430.470.500.740.550.570.600.630.700.520.560.680.670.720.640.58threewaycontradiction0.710.640.610.971.000.770.920.890.990.980.85threewayneutral0.790.700.620.910.990.680.860.790.960.960.83 Перформанс модели XLM весьма неплох, но надо сделать скидку на то, что это большая и довольно медленная модель класса large. На видеокарте, с которой я работал, XLM и BART обрабатывали за секунду чуть меньше 2 батчей по 32 пары текстов, RuBERT-base –  7 батчей в секунду, а RuBERT-tiny – аж 36 батчей в секунду.В целом, для задач zero-shot classification и распознавания entailment я рекомендую выбирать между умной и медленной cointegrated/rubert-base-cased-nli-twoway и глупой и быстрой cointegrated/rubert-tiny-bilingual-nli. Если же вам важно различать разницу между классами neutral и contradiction, то берите модель cointegrated/rubert-base-cased-nli-threeway, которая тоже работает весьма неплохо.Я не уверен, что мне удалось создать самые лучшие модели NLI для русского языка; наверняка в закромах Сбера или Яндекса есть варианты помощнее. Но зато мои модели выложены в открытый доступ, а значит, вы можете использовать их для задач NLI, классификации, и детекции парафраз уже сейчас. А если вы уже успели попробовать применить русские модели для NLI, то пишите в комменты: на каких данных применяли, какой результат получился, какое общее впечатление? И не забывайте лайкать этот пост 