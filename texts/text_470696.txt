

Почему Kaldi хорош для распознавания речи? (обновлено 25.12.2019) / Habr


              8  October  2019 at 19:06  Почему Kaldi хорош для распознавания речи? (обновлено 25.12.2019) Machine learning *Learning languages Natural Language Processing * 
        Sandbox
      
        Tutorial
           


Почему мне (и, надеюсь, вам) интересно распознавание речи? Во-первых, это направление является одним из самых популярных по сравнению с другими задачами компьютерной лингвистики, поскольку технология распознавания речи сейчас используется почти повсеместно – от распознавания простого «да/нет» в автоматическом колл-центре банка до способности поддерживать «светскую беседу» в «умной колонке» типа «Алисы». Во-вторых, чтобы система распознавания речи была качественным, необходимо найти самые эффективные средства для создания и настройки такой системы (одному из подобных средств и посвящена эта статья). Наконец, несомненным «плюсом» выбора специализации в области распознавания речи лично для меня является то, что для исследований в этой области необходимо владеть как программистскими, так и лингвистическими навыками. Это весьма стимулирует, заставляя приобретать знания в разных дисциплинах.

Почему именно Kaldi, ведь есть же и другие фреймворки для распознавания речи?

Для ответа на этот вопрос стоит рассмотреть существующие аналоги и используемые ими алгоритмы и технологии (алгоритмы, используемые в Kaldi, описаны далее в статье): 


CMU Sphinx

 CMU Sphinx (не путать с поисковым движком Sphinx!) – это система распознавания речи, созданная разработчиками из университета Карнеги-Меллон и состоящая из различных модулей для извлечения речевых признаков, распознавания речи (в том числе и на мобильных устройствах) и обучения такому распознаванию. CMU Sphinx использует скрытые марковские модели на акустико-фонетическом уровне распознавания и статистические N-граммные модели на лингвистическом уровне распознавания. Также в системе присутствуют ряд интересных возможностей: распознавание продолжительной речи (например, стенограмм или звукозаписей интервью), возможность подключения большого словаря в сотни тысяч словоформ, и т. п. Важно отметить, что система постоянно развивается, с каждой версией улучшаются качество распознавания и производительность. Также присутствуют кроссплатформенность и удобная документация. Из минусов использования данной системы можно выделить невозможность запустить CMU Sphinx «из коробки», т.к. даже для решения простых задач требуются знания по адаптации акустической модели, в сфере языкового моделирования и т.д.
Julius 

 Julius разрабатывалась японскими разработчиками с 1997 года, и сейчас проект поддерживается Advanced Science, Technology & Management Research Institute of Kyoto. Работа модели основана на N-граммах и контекстозависимых скрытых марковских моделях, система способна распознавать речь в реальном времени. В качестве недостатков можно назвать распространение только для модели японского языка (хотя существует проект VoxForge, который создает акустические модели и для других языков, в частности для английского языка) и отсутствие стабильных обновлений.
RWTH ASR

 Модель развивается специалистами из Рейнско-Вестфальского технического университета с 2001 года, состоит из нескольких библиотек и инструментов, написанных на языке C++. В проект также входят документация по установке, различные обучающие системы, шаблоны, акустические модели, языковые модели, поддержка нейронных сетей и т. д. При этом RWTH ASR практически не обладает кроссплатформенностью и имеет низкую скорость работы.
HTK

 HTK (Hidden Markov Model Toolkit) – это набор инструментов для распознавания речи, который был создан в Кембриджском университете в 1989 году. Инструментарий, основанный на скрытых марковских моделях, используется чаще всего как дополнительное средство для создания систем распознавания речи (например, этот фреймворк используют разработчики Julius). Несмотря на то, что исходный код является общедоступным, использование HTK для создания систем для конечных пользователей запрещено лицензией, из-за чего инструментарий сейчас не является популярным. Также система имеет относительно невысокие скорость и точность работы. 


В статье “Сравнительный анализ систем распознавания речи с открытым кодом” (https://research-journal.org/technical/sravnitelnyj-analiz-sistem-raspoznavaniya-rechi-s-otkrytym-kodom/) было проведено исследование, в ходе которого все системы были обучены на корпусе английского языка (160 часов) и применены на небольшом 10-часовом тестовом корпусе. В итоге выяснилось, что Kaldi имеет самую высокую точность распознавания, по скорости работы незначительно проигрывая конкурентам. Также система Kaldi способна предоставить пользователю наиболее богатый выбор алгоритмов для разных задач и очень удобна в использовании. При этом делается акцент на том, что неопытному пользователю может доставить неудобство работа с документацией, т.к. она рассчитана на специалистов по распознаванию речи. Но в целом, Kaldi подходит для научных исследований больше, чем её аналоги. 

Как установить Kaldi 

Скачиваем архив с репозитория на https://github.com/kaldi-asr/kaldi:

Распаковываем архив, заходим в kaldi-master/tools/extras.
Выполняем ./check_dependencies.sh: 


 Если после этого вы увидите не «all ok», то откройте файл kaldi-master/tools/INSTALL и выполните находящиеся там инструкции.
Выполняем make(находясь в kaldi-master/tools, не в kaldi-master/tools/extras):

Заходим в kaldi-master/src.
Выполняем ./configure --shared, при этом можно настроить установку с технологией CUDA или без нее, указав путь к установленной CUDA (./configure --cudatk-dir=/usr/local/cuda-8.0) или поменять изначальное значение «yes» на «no»(./configure --use-cuda=no) соответственно. 


Если при этом вы увидите: 




то либо вы не выполнили пункт 4, либо нужно самостоятельно скачать и установить OpenFst: http://www.openfst.org/twiki/bin/view/FST/FstDownload.
Выполняем make depend.
Выполняем make -j. Здесь рекомендуется ввести правильное число ядер процессора, которые вы будете использовать при сборке, например make -j 2 .
В результате получаем:


Пример использования модели с установленным Kaldi

В качестве примера я использовал модель kaldi-ru версии 0.6, cкачать её можно по этой ссылке: 


После скачивания заходим в файл kaldi-ru-0.6/decode.sh и указываем путь к установленной Kaldi, у меня это выглядит вот так:



Запускаем модель, указывая файл, речь в котором нужно распознать. Можно использовать файл decoder-test.wav, это специальный файл для теста, он уже есть в этой папке:



И вот что распознала модель:

 
Какие алгоритмы используются, что лежит в основе работы? 

Полная информация о проекте находится по адресу http://kaldi-asr.org/doc/, здесь же я выделю несколько главных моментов:


Для извлечения акустических признаков из входного сигнала используются либо широко известные MFCC (Mel-Frequency Cepstral Coefficients), либо чуть менее популярные PLP (Perceptual Linear prediction – см. H. Hermansky, “Perceptual linear predictive (PLP) analysis of speech”). В первом методе спектр исходного сигнала преобразуется из шкалы Герц в мел-шкалу, а затем с помощью обратного косинусного преобразования вычисляются кепстральные коэффициенты (https://habr.com/ru/post/140828/). Второй метод основан на регрессионном представлении речи: строится модель сигнала, которая описывает предсказание текущего отсчета сигнала линейной комбинацией – произведением известных отсчетов входных и выходных сигналов на коэффициенты линейного предсказания. Задача вычисления признаков речи сводится к нахождению этих коэффициентов при некоторых условиях.
Модуль акустического моделирования включает в себя скрытые марковские модели (HMM), модель смеси гауссовских распределений (GMM), глубокие нейронные сети, а именно Time-Delay Neural Networks (TDNN).
Языковое моделирование осуществляется с помощью конечного автомата-преобразователя, или FST (finite-state transducer). FST кодирует отображение из входной последовательности символов в выходную последовательность символов, при этом для перехода существуют веса, которые определяют вероятность вычисления входного символа в выходной.
Декодирование происходит при помощи алгоритма прямого-обратного хода.

О создании модели kaldi-ru-0.6

Для русского языка существует предобученная модель распознавания, созданная Николаем Шмырёвым, также известным на многих сайтах и форумах как nsh.


Для извлечения признаков использовался метод MFCC, а сама акустико-фонетическая модель основана на нейронных сетях типа TDNN. 
В качестве обучающей выборки послужили звуковые дорожки видеозаписей на русском языке, выкачанные с YouTube.
Для создания языковой модели использовались словарь CMUdict и именно та лексика, которая была в обучающей выборке. Из-за того, что словарь содержал похожие произношения разных слов, было решено присвоить каждому слову значение “вероятности” и их нормализовать.
Для обучения языковой модели использовался фреймворк RNNLM (recurrent neural network language models), основанный, как можно увидеть из названия, на рекуррентных нейронных сетях (вместо старых добрых N-грамм).


Сравнение с Google Speech API и Yandex Speech Kit

Наверняка у кого-то из читателей при чтении предыдущих пунктов возник вопрос: окей, то что Kaldi превосходит своих прямых аналогов мы разобрались, но что насчет систем распознавания от Google и Яндекс? Может быть, актуальность описанных ранее фреймворков сомнительна, если есть инструменты от этих двух гигантов? Вопрос действительно хорош, поэтому давайте потестируем!


В качестве датасета возьмем записи и соответствующие текстовые расшифровки с небезызвестного VoxForge. В результате, после распознавания каждой системой 3677 звуковых файлов я получил такие значения WER (Word Error Rate):



Записи с VoxForge примерно схожи по отсутствию фоновых шумов, интонации, скорости речи и т.д. Давайте усложним задачу: возьмем валидационный подкорпус корпуса open_stt, который включает в себя телефонные разговоры, аудиодорожки роликов YouTube и аудиокниг, и оценим работу с помощью WER и CER (Character Error Rate).


После получения текстовых расшифровок, я заметил, что Google и Яндекс (в отличие от Kaldi) распознали слова типа 

«один» как «1». Соответственно, возникла необходимость подкорректировать такие случаи (т.к. в эталонных расшифровках, которые предоставили авторы open_stt, все представлено в буквенном выражении), что повлияло на конечный результат:

 



Подводя итоги, можно сказать, что все системы справились с задачей примерно на одном уровне, и Kaldi не слишком уступила Yandex Speech Kit и Google Speech API. Во втором случае наиболее хорошие показатели у Yandex Speech Kit, т.к. он лучше всего распознаёт короткие аудиофайлы в сравнении с конкурентами, которые оказались неспособны распознать какую-то их часть (для Google количество этих файлов даже слишком велико). Наконец, стоит отметить, что Kaldi понадобилось более 12 часов для распознавания 28111 файлов, другие системы справились за гораздо меньшее время. Но при этом Yandex Speech Kit и Google Speech API – это «чёрные ящики», которые работают где-то далеко-далеко на чужих серверах и недоступны для тюнинга, а вот Kaldi можно своими руками адаптировать под особенности решаемой задачи – характерную лексику (профессионализмы, жаргон, разговорный слэнг), особенности произношения и т.п. И всё это бесплатно и без СМС! Система является своеобразным конструктором, который мы все можем использовать для создания чего-то необычного и интересного.


Выражаю благодарность команде Яндекс.Облако, которая помогла мне в осуществлении распознавания корпуса open_stt.


Я работаю в лаборатории АПДиМО НГУ:

Сайт: https://bigdata.nsu.ru/

Группа VK: https://vk.com/lapdimo    Tags: распознавание речиkaldiмашинное обучениенейросетикомпьютерная лингвистика Hubs: Machine learningLearning languagesNatural Language Processing          


